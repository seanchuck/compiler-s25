diff --git a/src/inter.rs b/src/inter.rs
index 5ec384b..d3a80c0 100644
--- a/src/inter.rs
+++ b/src/inter.rs
@@ -184,7 +184,7 @@ pub fn build_statement(ast_stmt: &AST, scope: Rc<RefCell<Scope>>) -> IRStatement
     match ast_stmt {
         AST::Statement(Statement::Assignment { location, expr, op: _ }) => {
             if let AST::Identifier(target) = location.as_ref() {
-                if scope.borrow().lookup(&target).is_none() {
+                if scope.borrow_mut().lookup(&target).is_none() {
                     panic!("Variable `{}` used before declaration", target);
                 }
 
@@ -274,7 +274,7 @@ pub fn build_expr(ast_expr: &AST, scope: Rc<RefCell<Scope>>) -> IRExpr {
         },
 
         AST::Identifier(name) => {
-            if let Some(entry) = scope.borrow().lookup(name) {
+            if let Some(entry) = scope.borrow_mut().lookup(name) {
                 IRExpr::Identifier(entry.clone())
             } else {
                 panic!("Variable `{}` used before declaration", name);
@@ -286,17 +286,135 @@ pub fn build_expr(ast_expr: &AST, scope: Rc<RefCell<Scope>>) -> IRExpr {
 }
 
 
+pub fn check_program(scoped_tree: &IRProgram) {
+    match scoped_tree {
+        IRProgram { global_scope, methods } => {
+            for (name, method_body) in methods.iter() {
+                println!("we got this method: {:?}", name);
+            }
+
+        }
+        _=> {
+            panic!("expected IRProgram!");
+        }
+    }
+}
+
+// pub fn check_method(scoped_tree: &IRMethod) {
+
+// }
+
+
+
+/// Pretty-print the IR program
+// pub fn pretty_print_program(program: &IRProgram) {
+//     println!("IRProgram:");
+//     println!("  Global Scope:");
+//     pretty_print_scope(&program.global_scope, 4); // Start at indent level 4
+
+//     println!("\n  Methods:");
+//     for (name, method) in &program.methods {
+//         println!("    - Method: {} -> {:?}", name, method.return_type);
+//         pretty_print_method(method, 6);
+//     }
+// }
+
+// /// Pretty-print an IR method
+// fn pretty_print_method(method: &IRMethod, indent: usize) {
+//     let indent_str = " ".repeat(indent);
+//     println!("{}Parameters: {:?}", indent_str, method.params);
+//     println!("{}Local Scope:", indent_str);
+//     pretty_print_scope(&method.scope, indent + 4);
+
+//     println!("{}Body:", indent_str);
+//     pretty_print_block(&method.body, indent + 4);
+// }
+
+// /// Pretty-print an IR block
+// fn pretty_print_block(block: &IRBlock, indent: usize) {
+//     let indent_str = " ".repeat(indent);
+//     println!("{}Scope:", indent_str);
+//     pretty_print_scope(&block.scope, indent + 4);
+
+//     println!("{}Statements:", indent_str);
+//     for stmt in &block.statements {
+//         pretty_print_statement(stmt, indent + 4);
+//     }
+// }
+
+// /// Pretty-print a scope and its variables
+// fn pretty_print_scope(scope: &Rc<RefCell<Scope>>, indent: usize) {
+//     let indent_str = " ".repeat(indent);
+//     let mut scope = scope.borrow_mut();
+
+//     println!("{}Parent Scope: {:?}", indent_str, scope.parent.as_ref().map(|_| "Exists"));
+//     println!("{}Variables:", indent_str);
+//     for (name, entry) in &scope.table {
+//         match entry {
+//             TableEntry::Variable { name, typ, is_array } => {
+//                 let array_str = if *is_array { "[]" } else { "" };
+//                 println!("{}  - {}: {:?}{}", indent_str, name, typ, array_str);
+//             }
+//             TableEntry::Method { .. } => {} // Methods are handled separately
+//         }
+//     }
+// }
+
+// /// Pretty-print an IR statement
+// fn pretty_print_statement(stmt: &Rc<IRStatement>, indent: usize) {
+//     let indent_str = " ".repeat(indent);
+//     match &**stmt {
+//         IRStatement::VarDecl { name, typ, is_array } => {
+//             let array_str = if *is_array { "[]" } else { "" };
+//             println!("{}VarDecl: {}: {:?}{}", indent_str, name, typ, array_str);
+//         }
+//         IRStatement::Assignment { target, expr } => {
+//             println!("{}Assignment: {} = {:?}", indent_str, target, expr);
+//         }
+//         IRStatement::MethodCall { method_name, args } => {
+//             println!("{}MethodCall: {}({:?})", indent_str, method_name, args);
+//         }
+//         IRStatement::If { condition, then_block, else_block } => {
+//             println!("{}If {:?}:", indent_str, condition);
+//             println!("{}Then Block:", indent_str);
+//             pretty_print_block(then_block, indent + 4);
+//             if let Some(else_block) = else_block {
+//                 println!("{}Else Block:", indent_str);
+//                 pretty_print_block(else_block, indent + 4);
+//             }
+//         }
+//         IRStatement::While { condition, block } => {
+//             println!("{}While {:?}:", indent_str, condition);
+//             pretty_print_block(block, indent + 4);
+//         }
+//         IRStatement::For { var, init, condition, update, block } => {
+//             println!("{}For {} = {:?}; {:?}; {:?}:", indent_str, var, init, condition, update);
+//             pretty_print_block(block, indent + 4);
+//         }
+//         IRStatement::Return { expr } => {
+//             println!("{}Return {:?}", indent_str, expr);
+//         }
+//         IRStatement::Break => println!("{}Break", indent_str),
+//         IRStatement::Continue => println!("{}Continue", indent_str),
+//     }
+// }
+
+
 /// Generates the IR from an AST
-pub fn generate_ir(
+pub fn check_semantics(
     file: &str,
     filename: &str,
     writer: &mut Box<dyn std::io::Write>,
     verbose: bool,
 ) {
     let parse_tree = parse(file, filename, writer, false).expect("Parsing failed");
-    let ir_program = build_program(&parse_tree);
+    let scoped_tree = build_program(&parse_tree);
 
     if verbose {
-        println!("{:#?}", ir_program);
+        println!("{:#?}", scoped_tree);
+        // pretty_print_program(&scoped_tree);
     }
+
+    check_program(&scoped_tree);
+
 }
diff --git a/src/main.rs b/src/main.rs
index 0463d6e..a0357fc 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -46,7 +46,7 @@ fn main() {
             parse::parse(&input, &filename, &mut writer, args.debug);
         }
         utils::cli::CompilerAction::Inter => {
-            inter::generate_ir(&input, &filename, &mut writer, args.debug);
+            inter::check_semantics(&input, &filename, &mut writer, args.debug);
             // semantics::check_semantics(&input, &filename, &mut writer, true);
         }
         utils::cli::CompilerAction::Assembly => {
diff --git a/src/scope.rs b/src/scope.rs
index 1cbc22b..d2f290a 100644
--- a/src/scope.rs
+++ b/src/scope.rs
@@ -4,7 +4,7 @@ needed for semantic validation, rather than full AST nodes.
 */
 
 use crate::ast::Type;
-use std::{cell::RefCell, collections::HashMap, fmt::format, rc::Rc};
+use std::{cell::RefCell, collections::HashMap, rc::Rc};
 
 
 /// Represents a scope in semantic analysis, containing:
diff --git a/src/token.rs b/src/token.rs
index 8187cb7..7beb356 100644
--- a/src/token.rs
+++ b/src/token.rs
@@ -4,6 +4,9 @@ Token data structures for scanner.
 
 use std::ops::Deref;
 
+
+// TODO: remove this wrapper and add `span`
+// to Token type instead
 #[derive(Debug, Clone, PartialEq)]
 #[allow(dead_code)]
 pub struct TokenInfo {
diff --git a/test.dcf b/test.dcf
index 98661e6..5366bd1 100644
--- a/test.dcf
+++ b/test.dcf
@@ -1,10 +1,5 @@
 int a;
-void outer() {
-}
-
 void inner() {
-  a = 3;
-  if (3 > 2) {
-    a = 5;
-  }
+  int a;
+  a=3;
 }
\ No newline at end of file
