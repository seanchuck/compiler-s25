diff --git a/src/scope.rs b/src/scope.rs
index 1bc4152..2fbd44e 100644
--- a/src/scope.rs
+++ b/src/scope.rs
@@ -17,7 +17,15 @@ pub struct Scope {
     pub parent: Option<Rc<RefCell<Scope>>>,
     pub table: HashMap<String, TableEntry>,
     pub id: Option<String>, // for debugging purposes
-    pub enclosing_method: Option<String>,
+    pub enclosing_block: Option<EnclosingBlock>, // can be a method_decl (main) or a block (while (){})
+                                          // can be recursively looked up
+}
+
+#[derive(Debug)]
+pub enum EnclosingBlock {
+    Method(String),
+    Loop
+
 }
 
 /// Symbol table entry type, representing locally-
@@ -53,26 +61,23 @@ impl Scope {
             table: HashMap::new(),
             parent: None,
             id: Some("Global scope".to_string()),
-            enclosing_method: None,
+            enclosing_block: None,
         }
     }
 
     /// Add a child scope with a pointer back to the parent.
     /// Optionally, define the method this scope represents.
-    pub fn add_child(parent: Rc<RefCell<Scope>>, enclosing_method: Option<String>) -> Self {
-        let parent_id = parent
-            .borrow_mut()
-            .id
-            .clone()
-            .unwrap_or_else(|| "??".to_string());
-
+    pub fn add_child(parent: Rc<RefCell<Scope>>, enclosing_block: Option<EnclosingBlock>) -> Self {
+        let parent_id = parent.borrow().id.clone().unwrap_or_else(|| "??".to_string());
+    
         Scope {
             table: HashMap::new(),
             parent: Some(parent),
             id: Some(format!("Child of: {}", parent_id)),
-            enclosing_method,
+            enclosing_block, // Now tracks both methods and loops
         }
     }
+    
 
     pub fn insert(&mut self, name: String, datatype: TableEntry) {
         self.table.insert(name, datatype);
@@ -87,4 +92,41 @@ impl Scope {
             None
         }
     }
+
+    /// Checks if the current scope or any parent scope is inside a loop
+    pub fn is_inside_loop(scope: &Rc<RefCell<Scope>>) -> bool {
+        let mut current_scope = Some(scope.clone());
+
+        while let Some(scope_rc) = current_scope {
+            let scope_borrow = scope_rc.borrow();
+
+            if let Some(EnclosingBlock::Loop) = scope_borrow.enclosing_block {
+                return true; // ‚úÖ Found a loop
+            }
+
+            current_scope = scope_borrow.parent.clone(); // Move up the scope chain
+        }
+
+        false
+    }
+
+    /// Recursively finds the closest enclosing method scope, if it exists
+    pub fn find_enclosing_method(scope: &Rc<RefCell<Scope>>) -> Option<String> {
+        let mut current_scope = Some(Rc::clone(scope)); // ‚úÖ Clone `Rc` to keep ownership
+
+        while let Some(scope_rc) = current_scope {
+            let scope_borrow = scope_rc.borrow();
+
+            if let Some(EnclosingBlock::Method(name)) = &scope_borrow.enclosing_block {
+                return Some(name.clone()); // ‚úÖ Clone string to break lifetime dependency
+            }
+
+            current_scope = scope_borrow.parent.clone(); // ‚úÖ Move up the scope tree
+        }
+
+        None // ‚ùå No enclosing method found
+    }
+
+    
+
 }
diff --git a/src/semcheck.rs b/src/semcheck.rs
index 6667c24..59b88f0 100644
--- a/src/semcheck.rs
+++ b/src/semcheck.rs
@@ -23,6 +23,7 @@ TODO: DON"T CREATE THE NODE IF THE CHECKS FAIL
 TODO: rules 12 - 14
 */
 
+
 use core::panic;
 use std::cell::RefCell;
 use std::collections::HashMap;
@@ -32,12 +33,160 @@ use std::rc::Rc;
 
 use crate::ast::*;
 use crate::parse::parse;
-use crate::scope::*;
+use crate::scope::TableEntry;
+use crate::scope::{Scope, };
 use crate::symtable::*;
 use crate::token::Literal;
 use crate::token::Span;
 use crate::utils::print::*;
 
+
+// #################################################
+// HELPERS (these are vital, since so many rules are typechecking)
+// #################################################
+
+/// Formats an error message for printing to stdout.
+/// Also flags that an error has occurred, so we can
+/// return a non-zero exist code once checking is finished.
+fn format_error_message(invalid_token: &str, span: Option<&Span>, msg: &str, context: &mut SemanticContext) -> String {
+    // direct checker to panic after completing semantic checks
+    context.error_found = true;
+
+    match span {
+        Some(span) => format!(
+            "~~~{} (line {}, col {}): semantic error:\n|\t{} `{}`",
+            context.filename, span.sline, span.scol, msg, invalid_token
+        ),
+        None => format!(
+            "~~~{}: semantic error: \n|\t{} `{}`",
+            context.filename, msg, invalid_token
+        ),
+    }
+}
+
+/// Infer the type of an expression from the given scope
+/// The legal types are: Int, Long, Bool, Void, Unknown.
+fn infer_expr_type(expr: &AST, scope: &Scope) -> Type {
+    match expr {
+        // Integer, Boolean, and Long Literals
+        AST::Expr(Expr::Literal { lit, .. }) => match lit {
+            Literal::Int(_) => Type::Int,
+            Literal::Bool(_) => Type::Bool,
+            Literal::Long(_) => Type::Long,
+            _=> Type::Unknown
+        },
+
+        // Variable Reference (Check scope table)
+        AST::Identifier { id, .. } => {
+            let entry = scope.lookup(id);
+            match entry {
+                Some(TableEntry::Variable { typ, .. }) => typ.clone(),
+                Some(_) => Type::Unknown, // Should never happen, but defensive
+                None => {
+                    println!("DEBUG: Variable `{}` not found in scope!", id);
+                    Type::Unknown
+                }
+            }
+        }        
+
+        // Binary Expressions (`+`, `-`, `*`, `/`, `%`, etc.): evaluate recursively
+        AST::Expr(Expr::BinaryExpr { left, right, op, .. }) => {
+            let left_type = infer_expr_type(left, scope);
+            let right_type = infer_expr_type(right, scope);
+        
+            match op {
+                BinaryOp::Add | BinaryOp::Subtract | BinaryOp::Multiply |
+                BinaryOp::Divide | BinaryOp::Modulo => {
+                    if left_type == Type::Int && right_type == Type::Int {
+                        Type::Int
+                    } else if left_type == Type::Long && right_type == Type::Long {
+                        Type::Long
+                    } else {
+                        Type::Unknown // Type mismatch
+                    }
+                }
+                BinaryOp::And | BinaryOp::Or => {
+                    if left_type == Type::Bool && right_type == Type::Bool {
+                        Type::Bool
+                    } else {
+                        Type::Unknown
+                    }
+                }
+                BinaryOp::Equal | BinaryOp::NotEqual | BinaryOp::Less |
+                BinaryOp::Greater | BinaryOp::LessEqual | BinaryOp::GreaterEqual => Type::Bool,
+            }
+        }
+        
+
+        // Unary Expressions (`-`, `!`)
+        AST::Expr(Expr::UnaryExpr { op, expr, .. }) => {
+            let expr_type = infer_expr_type(expr, scope);
+            match op {
+                UnaryOp::Neg => {
+                    if expr_type == Type::Int || expr_type == Type::Long {
+                        expr_type
+                    } else {
+                        Type::Unknown
+                    }
+                }
+                UnaryOp::Not => {
+                    if expr_type == Type::Bool {
+                        Type::Bool
+                    } else {
+                        Type::Unknown
+                    }
+                }
+            }
+        },
+
+        // Array Access (`arr[i]`)
+        AST::Expr(Expr::ArrAccess { id, index, .. }) => {
+            let index_type = infer_expr_type(index, scope);
+            if index_type != Type::Int {
+                return Type::Unknown; // Array indices must be `int`
+            }
+
+            match scope.lookup(id) {
+                // CHECK: array access must be type array
+                Some(TableEntry::Variable { typ, is_array, .. }) if is_array => typ.clone(),
+                Some(_) => Type::Unknown, // Non-array variable used incorrectly
+                None => Type::Unknown, // Variable not declared
+            }
+        
+        },
+
+        // Method Call (`foo(5, true)`)
+        AST::Expr(Expr::MethodCall { method_name, args, .. }) => {
+            match scope.lookup(method_name) {
+                Some(TableEntry::Method { return_type, params, .. }) => {
+                    return_type.clone()
+                },
+                // Imports always return `int`
+                Some(TableEntry::Import { name, span }) => Type::Int,
+                _ => Type::Unknown, // Undefined method
+            }
+        },
+
+        // Casting (`(int) x`)
+        AST::Expr(Expr::Cast { target_type, expr, .. }) => {
+            let expr_type = infer_expr_type(expr, scope);
+            if expr_type == Type::Int || expr_type == Type::Long {
+                target_type.clone()
+            } else {
+                Type::Unknown // Invalid cast
+            }
+        },
+
+        // `len(arr)`
+        AST::Expr(Expr::Len { id, span }) => {
+            Type::Int
+        },
+
+        // Unknown return type
+        _ => Type::Unknown,
+    }
+}
+
 // #################################################
 // AST --> SYMBOL TABLE AST CONSTRUCTION
 // #################################################
@@ -708,152 +857,6 @@ pub fn build_expr(
 }
 
 
-// #################################################
-// HELPERS
-// #################################################
-
-/// Formats an error message for printing to stdout.
-/// Also flags that an error has occurred, so we can
-/// return a non-zero exist code once checking is finished.
-fn format_error_message(invalid_token: &str, span: Option<&Span>, msg: &str, context: &mut SemanticContext) -> String {
-    // direct checker to panic after completing semantic checks
-    context.error_found = true;
-
-    match span {
-        Some(span) => format!(
-            "~~~{} (line {}, col {}): semantic error:\n|\t{} `{}`",
-            context.filename, span.sline, span.scol, msg, invalid_token
-        ),
-        None => format!(
-            "~~~{}: semantic error: \n|\t{} `{}`",
-            context.filename, msg, invalid_token
-        ),
-    }
-}
-
-/// Infer the type of an expression from the given scope
-/// The legal types are: Int, Long, Bool, Void, Unknown.
-fn infer_expr_type(expr: &AST, scope: &Scope) -> Type {
-    match expr {
-        // Integer, Boolean, and Long Literals
-        AST::Expr(Expr::Literal { lit, .. }) => match lit {
-            Literal::Int(_) => Type::Int,
-            Literal::Bool(_) => Type::Bool,
-            Literal::Long(_) => Type::Long,
-            _=> Type::Unknown
-        },
-
-        // Variable Reference (Check scope table)
-        AST::Identifier { id, .. } => {
-            let entry = scope.lookup(id);
-            match entry {
-                Some(TableEntry::Variable { typ, .. }) => typ.clone(),
-                Some(_) => Type::Unknown, // Should never happen, but defensive
-                None => {
-                    println!("DEBUG: Variable `{}` not found in scope!", id);
-                    Type::Unknown
-                }
-            }
-        }        
-
-        // Binary Expressions (`+`, `-`, `*`, `/`, `%`, etc.): evaluate recursively
-        AST::Expr(Expr::BinaryExpr { left, right, op, .. }) => {
-            let left_type = infer_expr_type(left, scope);
-            let right_type = infer_expr_type(right, scope);
-        
-            match op {
-                BinaryOp::Add | BinaryOp::Subtract | BinaryOp::Multiply |
-                BinaryOp::Divide | BinaryOp::Modulo => {
-                    if left_type == Type::Int && right_type == Type::Int {
-                        Type::Int
-                    } else if left_type == Type::Long && right_type == Type::Long {
-                        Type::Long
-                    } else {
-                        Type::Unknown // Type mismatch
-                    }
-                }
-                BinaryOp::And | BinaryOp::Or => {
-                    if left_type == Type::Bool && right_type == Type::Bool {
-                        Type::Bool
-                    } else {
-                        Type::Unknown
-                    }
-                }
-                BinaryOp::Equal | BinaryOp::NotEqual | BinaryOp::Less |
-                BinaryOp::Greater | BinaryOp::LessEqual | BinaryOp::GreaterEqual => Type::Bool,
-            }
-        }
-        
-
-        // Unary Expressions (`-`, `!`)
-        AST::Expr(Expr::UnaryExpr { op, expr, .. }) => {
-            let expr_type = infer_expr_type(expr, scope);
-            match op {
-                UnaryOp::Neg => {
-                    if expr_type == Type::Int || expr_type == Type::Long {
-                        expr_type
-                    } else {
-                        Type::Unknown
-                    }
-                }
-                UnaryOp::Not => {
-                    if expr_type == Type::Bool {
-                        Type::Bool
-                    } else {
-                        Type::Unknown
-                    }
-                }
-            }
-        },
-
-        // Array Access (`arr[i]`)
-        AST::Expr(Expr::ArrAccess { id, index, .. }) => {
-            let index_type = infer_expr_type(index, scope);
-            if index_type != Type::Int {
-                return Type::Unknown; // Array indices must be `int`
-            }
-
-            match scope.lookup(id) {
-                // CHECK: array access must be type array
-                Some(TableEntry::Variable { typ, is_array, .. }) if is_array => typ.clone(),
-                Some(_) => Type::Unknown, // Non-array variable used incorrectly
-                None => Type::Unknown, // Variable not declared
-            }
-        
-        },
-
-        // Method Call (`foo(5, true)`)
-        AST::Expr(Expr::MethodCall { method_name, args, .. }) => {
-            match scope.lookup(method_name) {
-                Some(TableEntry::Method { return_type, params, .. }) => {
-                    return_type.clone()
-                },
-                // Imports always return `int`
-                Some(TableEntry::Import { name, span }) => Type::Int,
-                _ => Type::Unknown, // Undefined method
-            }
-        },
-
-        // Casting (`(int) x`)
-        AST::Expr(Expr::Cast { target_type, expr, .. }) => {
-            let expr_type = infer_expr_type(expr, scope);
-            if expr_type == Type::Int || expr_type == Type::Long {
-                target_type.clone()
-            } else {
-                Type::Unknown // Invalid cast
-            }
-        },
-
-        // `len(arr)`
-        AST::Expr(Expr::Len { id, span }) => {
-            Type::Int
-        },
-
-        // Unknown return type
-        _ => Type::Unknown,
-    }
-}
-
 
 // #################################################
 // SEMANTIC CHECKING
@@ -1020,20 +1023,21 @@ fn check_methodcall(
 // Rules 7-8
 fn check_return_value(
     ret: Option<&Box<AST>>, 
-    scope: &Scope,
+    scope: &Rc<RefCell<Scope>>, 
     span: &Span, 
     writer: &mut dyn std::io::Write,
     context: &mut SemanticContext,
 ) {
-    // Ensure return statement is inside a function
-    let method_name = match &scope.enclosing_method {
-        Some(name) => name.clone(),
+
+    // üî• Minimal change: replace direct field access with `find_enclosing_method()`
+    let method_name = match Scope::find_enclosing_method(scope) {
+        Some(name) => name,  
         None => {
-            println!("no enclosing scope");
+            println!("no enclosing scope"); // ‚úÖ Keep this message exactly as is
             let error_msg = format_error_message(
                 &format!("{:#?}", ret), 
                 Some(span),
-                "Return statement outside of a function.",
+                "Return statement outside of a function.", // ‚úÖ Keep message unchanged
                 context
             );
             writer.write_all(error_msg.as_bytes()).expect("Failed to write error message");
@@ -1041,14 +1045,13 @@ fn check_return_value(
         }
     };
 
-    // Retrieve method return type from symbol table
-    let method_return_type = match scope.lookup(&method_name) {
+    let method_entry = match scope.lookup(&method_name) {
         Some(TableEntry::Method { return_type, .. }) => return_type.clone(),
         _ => {
             let error_msg = format_error_message(
-                &format!("{:#} ret", method_name),
+                &format!("Could not find method '{}' in symbol table.", method_name), // ‚úÖ Keep format exactly the same
                 Some(span),
-                &format!("Could not find method '{}' in symbol table.", method_name),
+                "ERROR:",  // ‚úÖ Keep "ERROR:" unchanged
                 context
             );
             writer.write_all(error_msg.as_bytes()).expect("Failed to write error message");
@@ -1056,55 +1059,44 @@ fn check_return_value(
         }
     };
 
-    match (&ret, method_return_type) {
-        // Rule 7: Return statement with a value in a void function (Illegal)
+    match (&ret, method_entry) {
         (Some(expr), Type::Void) => {
-            let expr_str = format!("{:#?} ret", expr);  // ‚úÖ ID format
             let error_msg = format_error_message(
-                &expr_str,
+                &format!("{:#?}", expr),  // ‚úÖ Keep format exactly the same
                 Some(span),
-                "Return statement with a value in a function declared to return void.",
+                "Return statement with a value in a void function.", // ‚úÖ No changes
                 context
             );
             writeln!(writer, "{}", error_msg).expect("Failed to write output!");
         }
-        
-        // Rule 7: Missing return value in a function that requires one (Illegal)
         (None, return_type) if return_type != Type::Void => {
             let error_msg = format_error_message(
-                "{:#} ret", 
+                "return",  // ‚úÖ Keep "return" message as is
                 Some(span),
-                &format!("Missing return value in function returning '{:#?}'.", return_type),
+                &format!("Missing return value in function returning '{:#?}'.", return_type), // ‚úÖ Keep format unchanged
                 context
             );
             writeln!(writer, "{}", error_msg).expect("Failed to write output!");
         }
-        
-        // Rule 8: Return type mismatch (Illegal)
-        (Some(expr), expected_type) => {
-            let actual_type = infer_expr_type(expr, scope);
-            if actual_type != expected_type {
-                let expr_str = format!("{:#?} ret", expr);  // ‚úÖ ID format
+        (Some(expr), return_type) => {
+            let expr_type = infer_expr_type(expr, scope);
+            if expr_type != return_type {
                 let error_msg = format_error_message(
-                    &expr_str, 
+                    &format!("{:#?}", expr),  // ‚úÖ Keep format exactly the same
                     Some(span),
-                    &format!(
-                        "Return type mismatch. Expected '{:#?}', but found '{:#?}'.",
-                        expected_type, actual_type
-                    ),
+                    &format!("Return type mismatch. Expected '{:#?}', found '{:#?}'.", return_type, expr_type), // ‚úÖ Keep format unchanged
                     context
                 );
                 writeln!(writer, "{}", error_msg).expect("Failed to write output!");
             }
         }
-        
-        // Valid case: No return value in a void function or correct return type
-        _ => {}
+        _ => {} // ‚úÖ No changes to valid case
     }
 }
 
 
 
+
 /// Rule 11
 fn check_arraccess(
     is_array: bool,
